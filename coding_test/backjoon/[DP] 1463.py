# 동적계획법은 최적 부문 구조, 중복되는 문제 활용이 충족되어야한다.
# 피보나치 수열 같은 점화식이 대표적인 예시로 a_n = a_n-1 + a_n-2 구조이다.

# 만약 풀고있는 문제에서 점화식을 찾았다면 동적계획법으로 풀어야한다.
# 1463번 문제도 점화식을 찾아 이를 구현하는 문제이다.
# n % 3 == 0 인 경우 n번째는 n/3번째 위치의 값에 1을 더하는 것과 같다.
# n % 2 == 0 인 경우 n번째는 n/2번째 위치의 값에 1을 더하는 것과 같다.
# 1을 빼야하는 경우 n번째는 n-1번째 위치의 값에 1을 더하는 것과 같다.

# 이때 어떠한 값은 3개 중 2개 조건을 충족하는 경우가 있다.
# 예로들어 24의 경우 n%3 = 0이고 n%2도 0인 경우이므로 두 종류의 점화식 모두 충족한다.
# 이럴 경우 8번째 값 + 1 또는 12번째 값 + 1 중 더 작은 값을 선택해야한다.

# 값이 커지게 되면 n%3 = 0, n%2 =0, -1일 때 모두 비교해서 더 작은 값이 나온 경우를 택해야한다.
# 결국 3종류 모두를 비교해서 구해야하므로 값을 구할 때 3개의 결과값을 개별 한 번씩 비교하는 방식으로 알고리즘을 짜야한다.
# 그런 이유에서 소스코드에서 If를 2번 사용한 것이다.


#### 배울점 #####
# 100만 1로 설정하는 이유는 index와 찾고자 하는 값의 결과를 일치시키기 위함
# ex) 100의 결과를 알고 싶으면 list[99]로 해야하는데 이것보다 list[100]이 직관적이기 때문임.

#

import sys

num = int(sys.stdin.readline())

dp = [0] * (1000001)  # 최대 100만까지 이므로

for n in range(2, 1000001):
    dp[n] = dp[n - 1] + 1

    if n % 3 == 0:
        dp[n] = min(dp[n], dp[(n) // 3] + 1)

    if n % 2 == 0:
        dp[n] = min(dp[n], dp[(n) // 2] + 1)


print(dp[num])
