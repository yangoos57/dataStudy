# BFS # 완전탐색  # 최단거리 # 이코테

# 괴물 문제 해결 방식
# 최단 거리를 묻는 유형은 BFS로 해결한다. * BFS는 간선 간 이용비용이 모두 동일할 때에 최단거리를 구할 수 있다.
# 얼음 얼리기 유형(DFS)에서는 모든 Graph를 하나씩 탐색하며 DFS가 가능한 영역을 찾았다.
# DFS은 한번 영역을 찾으면 쭉 들어가서 끝을 찍은 다음 돌아오는 유형이라면
# BFS은 차근차근 같은 단계를 마치 벽돌 쌓아가듯 채워가는 유형이다.
# 느낌상 DFS가 최단거리를 찾고 BFS가 얼음을 하나하나 채워가는 느낌인데 실제로는 정반대이다.
# 이렇게 생각하자. DFS는 윤곽을 잡은 뒤 내부를 채워나가는 방식,
# BFS는 특정 노드가 몇 번째 단계에 위치한 노드인지 알려주는 방식이다.
# (BFS는 같은 위치의 노드의 방문이 완료되어야 다음 위치의 노드를 방문하기 때문)

# 길찾기 문제는 도착지 노드가 몇번째 단계에 위치한 노드인지를 확인하는 문제라 할 수 있다.
# 그래프 값이 0이거나 그래프 크기 밖으로 벗어나는 값을 제외한다.
# 1이 있는 노드를 방문해가며 몇번째 단계의 노드인지를 체크한다.
# 그래프가 1인 경우 다음 노드가 있는지 찾기 위해 해당 노드를 탐색하기 위해 queue에 넣는다.
# 현 노드 단계 = 이전 노드 단계 + 1 해준다.


from collections import deque

n, m = 4, 5
graph = [
    [0, 0, 0, 0, 0, 0],
    [0, 1, 0, 1, 0, 1],
    [0, 1, 1, 1, 1, 1],
    [0, 0, 0, 0, 0, 1],
    [0, 1, 1, 1, 1, 1],
]


def bfs(a, b):
    # 1,1 시작 영역 담기
    queue = deque()
    queue.append((a, b))

    # 모든 영역을 탐색하게되면 queue == False이므로 while 종료

    x_axis = [0, 0, -1, 1]  # 상하좌우
    y_axis = [1, -1, 0, 0]
    while queue:
        x, y = queue.popleft()

        # 상하좌우 값 불러오기
        for i in range(4):
            nx = x + x_axis[i]
            ny = y + y_axis[i]

            # 영역 밖인 경우
            if nx > n or nx < 1 or ny > m or ny < 1:
                continue

            # 벽 또는 괴물인 경우
            elif graph[nx][ny] == 0:
                continue

            # 길인 경우
            elif graph[nx][ny] == 1:
                # 상하좌우 노드 중 길이라 판단된 경우 이전 길에 + 1 을 더한다.
                graph[nx][ny] = graph[x][y] + 1

                # 해당 노드는 길이므로 다시 관련 노드를 탐색한다.
                queue.append((nx, ny))

    return graph[n][m]


print(bfs(1, 1))
